name: TG Group Listener & Redeem

on:
  workflow_dispatch:

jobs:
  tg-listen:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install telethon requests

      - name: Run TG Listener
        env:
          # å¤šè´¦å· TG ç™»å½•ä¿¡æ¯ï¼Œapi_id:api_hash,api_id:api_hash
          TG_APIS: ${{ secrets.TG_APIS }}
          
          # æ¯ä¸ª TG è´¦å·å¯¹åº”çš„ session base64ï¼Œæ ¼å¼ TG<api_id>
          # ä¾‹å¦‚ TG12345
          TG11027029: ${{ secrets.TG11027029 }}
          TG12965303: ${{ secrets.TG12965303 }}

          # å¯é€‰ä»£ç†
          PROXIES: ${{ secrets.PROXIES }}

          # ç¾¤èŠä¿¡æ¯
          GROUP: "@incudal_com"

          # ç›®æ ‡æˆå‘˜ ID
          TARGET_IDS: "-1003435357437,1966630851"

          # åŒ¹é…åˆ°æ¶ˆæ¯åæ‰§è¡Œå‘½ä»¤
          COMMAND: "python scripts/redeem.py"

          # ç›‘å¬æ—¶é—´ï¼ˆç§’ï¼‰
          LISTEN_SECONDS: 60

          # æŒ‡å®šè¦ä½¿ç”¨çš„ TG è´¦å·
          USE_API_ID: "11027029"

        run: |
          mkdir -p scripts
          cat > scripts/listen_group.py << 'EOF'
          import asyncio
          import os
          import base64
          import subprocess
          from telethon import TelegramClient, events
          
          TG_APIS = os.getenv("TG_APIS")
          PROXIES = os.getenv("PROXIES", "").strip()
          GROUP = os.getenv("GROUP")
          TARGET_IDS = os.getenv("TARGET_IDS", "").split(",")
          COMMAND = os.getenv("COMMAND")
          LISTEN_SECONDS = int(os.getenv("LISTEN_SECONDS", "60"))
          USE_API_ID = os.getenv("USE_API_ID")  # æŒ‡å®šç™»å½•è´¦å·

          RESULTS = []

          proxy = None
          if PROXIES:
              proxy_lines = [p.strip() for p in PROXIES.splitlines() if p.strip()]
              proxy = proxy_lines[0] if proxy_lines else None

          # è·å–æŒ‡å®šè´¦å·ä¿¡æ¯
          api_id = None
          api_hash = None
          session_b64 = None
          for item in TG_APIS.split(","):
              id_, hash_ = item.split(":")
              if id_ == USE_API_ID:
                  api_id = int(id_)
                  api_hash = hash_
                  session_b64 = os.getenv(f"TG{id_}")
                  break

          if not all([api_id, api_hash, session_b64]):
              raise SystemExit(f"âŒ æœªæ‰¾åˆ°æŒ‡å®š TG è´¦å· {USE_API_ID}")

          session_file = f"TG{api_id}.session"
          with open(session_file, "wb") as f:
              f.write(base64.b64decode(session_b64))

          client = TelegramClient(session_file, api_id, api_hash, proxy=None)

          @client.on(events.NewMessage(chats=GROUP))
          async def handler(event):
              sender = await event.get_sender()
              text = event.raw_text
              sender_id = str(sender.id)

              print(f"æ”¶åˆ°æ¶ˆæ¯ | ç”¨æˆ·: {sender.username} | ID: {sender_id} | å†…å®¹: {text}")

              if sender_id in TARGET_IDS:
                  print(f"åŒ¹é…åˆ°ç›®æ ‡ç”¨æˆ· {sender_id}ï¼Œæ‰§è¡Œå‘½ä»¤: {COMMAND}")
                  try:
                      result = subprocess.run(COMMAND, shell=True, capture_output=True, text=True)
                      print(f"å‘½ä»¤è¾“å‡º:\n{result.stdout}\n{result.stderr}")
                      RESULTS.append(f"ç”¨æˆ· {sender.username}({sender_id}) æ¶ˆæ¯è§¦å‘ï¼š\n{result.stdout}")
                  except Exception as e:
                      print(f"æ‰§è¡Œå‘½ä»¤å¤±è´¥: {e}")
                      RESULTS.append(f"ç”¨æˆ· {sender.username}({sender_id}) æ‰§è¡Œå¤±è´¥ï¼š{e}")

          async def send_summary():
              text = "ğŸ“Š TG æ¶ˆæ¯è§¦å‘ç»“æœ\n\n" + "\n\n".join(RESULTS) if RESULTS else "ğŸ“Š æ²¡æœ‰è§¦å‘ä»»ä½•å‘½ä»¤"
              await client.send_message("me", text)

          async def main():
              await client.start()
              print(f"âœ… å·²ç™»å½• TG ç”¨æˆ· {api_id}ï¼Œå¼€å§‹ç›‘å¬ç¾¤èŠæ¶ˆæ¯...")
              await asyncio.sleep(LISTEN_SECONDS)
              await send_summary()
              await client.disconnect()
              print("ç›‘å¬ç»“æŸ")

          if __name__ == "__main__":
              asyncio.run(main())
          EOF

          python scripts/listen_group.py
