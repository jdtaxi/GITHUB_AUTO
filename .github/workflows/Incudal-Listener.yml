import asyncio
import os
import base64
import re
import subprocess
import time
from telethon import TelegramClient, events

TG_APIS = os.getenv("TG_APIS")
GROUP = os.getenv("GROUP")
TARGET_IDS = os.getenv("TARGET_IDS", "").split(",")
LISTEN_SECONDS = int(os.getenv("LISTEN_SECONDS", "120"))
USE_API_ID = os.getenv("USE_API_ID")
USER_SESSION = os.getenv("USER_SESSION")

RESULTS = []

# è·å–æŒ‡å®šè´¦å·ä¿¡æ¯
api_id = None
api_hash = None
session_b64 = None
for item in TG_APIS.split(","):
    id_, hash_ = item.split(":")
    if id_ == USE_API_ID:
        api_id = int(id_)
        api_hash = hash_
        session_b64 = os.getenv(f"TG{id_}")
        break

if not all([api_id, api_hash, session_b64]):
    raise SystemExit(f"âŒ æœªæ‰¾åˆ°æŒ‡å®š TG è´¦å· {USE_API_ID}")

session_file = f"TG{api_id}.session"
with open(session_file, "wb") as f:
    f.write(base64.b64decode(session_b64))

client = TelegramClient(session_file, api_id, api_hash)

CODE_REGEX = re.compile(r'\b[crdth]-[\w-]{8,40}\b')

@client.on(events.NewMessage(chats=GROUP))
async def handler(event):
    sender = await event.get_sender()
    text = event.raw_text
    sender_id = str(sender.id)

    print(f"æ”¶åˆ°æ¶ˆæ¯ | ç”¨æˆ·: {sender.username} | ID: {sender_id} | å†…å®¹: {text}", flush=True)

    if sender_id in TARGET_IDS:
        codes = CODE_REGEX.findall(text)
        if codes:
            codes_text = "\n".join(codes)
            os.environ["REDEEM_TEXT"] = codes_text
            print(f"åŒ¹é…åˆ°å…‘æ¢ç : {codes_text}ï¼Œå¼€å§‹è°ƒç”¨ redeem.py", flush=True)
            try:
                process = subprocess.Popen(
                    ["python", "scripts/redeem.py"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True
                )
                for line in process.stdout:
                    print(line, end="", flush=True)
                process.wait()
                RESULTS.append(f"ç”¨æˆ· {sender.username}({sender_id}) æ¶ˆæ¯è§¦å‘ï¼š\n{codes_text}")
            except Exception as e:
                print(f"æ‰§è¡Œ redeem.py å¤±è´¥: {e}", flush=True)
                RESULTS.append(f"ç”¨æˆ· {sender.username}({sender_id}) æ‰§è¡Œå¤±è´¥ï¼š{e}")

async def send_summary():
    text = "ğŸ“Š TG æ¶ˆæ¯è§¦å‘å…‘æ¢ç»“æœ\n\n" + "\n\n".join(RESULTS) if RESULTS else "ğŸ“Š æ²¡æœ‰è§¦å‘ä»»ä½•å…‘æ¢"
    await client.send_message("me", text)

async def main():
    await client.start()
    print(f"âœ… å·²ç™»å½• TG ç”¨æˆ· {api_id}ï¼Œå¼€å§‹ç›‘å¬ç¾¤èŠæ¶ˆæ¯...", flush=True)

    start_time = time.time()
    total_minutes = LISTEN_SECONDS // 60
    next_minute = 1

    while True:
        elapsed = time.time() - start_time
        remaining = LISTEN_SECONDS - elapsed
        if remaining <= 0:
            break

        minutes_left = int(remaining // 60)
        if minutes_left < total_minutes - next_minute + 1:
            print(f"â± ç›‘å¬å‰©ä½™æ—¶é—´: {minutes_left} åˆ†é’Ÿ", flush=True)
            next_minute += 1

        await asyncio.sleep(1)

    print("\nâ° ç›‘å¬ç»“æŸï¼Œå‘é€æ±‡æ€»...", flush=True)
    await send_summary()
    await client.disconnect()
    print("âœ… ç›‘å¬ç»“æŸ", flush=True)

if __name__ == "__main__":
    if not USER_SESSION:
        raise RuntimeError("âŒ USER_SESSION æœªè®¾ç½®")
    asyncio.run(main())
